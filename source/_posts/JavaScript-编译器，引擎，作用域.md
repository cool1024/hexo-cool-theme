---
title: JavaScript-编译器，引擎，作用域(一)
date: 2019-06-25 21:44:14
tags: javascript
categories: Web开发
---

## 基本概念
通常把JavaScript归类为“动态”或“解释执行”的语音，但实际上它是一门编译语言。在传统的编译语言中，程序的源代码在执行之前都会经历三个步骤：
* **词法分析**
    这个过程会把由字符组成的字符串分解成（对编程语音来说）有意义的代码块，这些代码块称为词法单元；如“var a = 0”会被分解成"var","a","=","0"
* **语法分析**
    这个过程把词法单元（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树称为"抽象语法树(AST)",var a = 0的抽象语法树可能会有个一个变量声明的顶级节点，接着是一个变量标识节点（值为a）的子节点,以及一个AssignmentExpression的子节点。AssignmentExpression又有一个数字文字（值是2）的子节点
* **代码生成**
    将抽象语法树转换成可执行代码
<!-- more -->

## JavaScript引擎
比起编译过程只有3步的语言的编译器，JavaScript引擎要复杂的多。它需要在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括冗余元素进行优化。
JavaScript引擎的编译过程不是发生在构建之前的（不是直接把代码编译成可执行的代码-打包成应用程序，然后双击运行就好了～），大部分编译都是发生在代码片段要执行的前几微秒。

一个JavaScript代码的运行需要由3个东东协同工作
* **引擎**
从头倒胃负责整个程序的编译及其执行过程
* **编译器**
协助引擎;负责词法，语法分析，代码生成
* **作用域**
协助引擎;负责收集和维护由所有变量组成的一系列查询，并按一套严格的规则确定当前执行的代码有没有这些变量的访问权限

对于代码片段`var a = 1`,编译器会做如下处理：
1. 遇到var a,编译器询问作用域是否已经在当前作用域中是否已经有一个这个名称的变量了，如果有的话，编译器会忽略这个声明，继续编译；否则它会请求作用域在当前作用域中新增这个变量（名称为a）
2. 编译器为引擎生成可以运行的代码，这些代码用来处理 a = 2 这个赋值操作。引擎运行时，先询问作用域，当前作用域中有没有名称为a的变量，如果有引擎就使用这个变量，如果没有那么它会向外层嵌套的作用域进行查询直到找到了或查到了最外层作用域（全局作用域）为止，如果最后找到了那么就将2赋值给找到的a变量,如果最后没有找到，那么引擎抛出一个异常

参考代码

```js
var a = 2;
```

```js
var a;
a = 2;
```

如果直接执行这样的代码你可能会得到一个错误`ReferenceError: a is not defined`,然而有些浏览器如果没有设置严格模式，它可能依然有效(这里我们使用了ES5的严格模式‘use strict’)
```js
'use strict'
 a = 2;
```

注意 not defined 和 undefiend的区别，没有声明直接使用变量为`ReferenceError: xxx is not defined`,只声明没有赋值就会默认为undefined的初始值

```js
'use strict'
var b
console.log(b) // 打印 undefined
a = 2 // 抛出异常 Uncaught ReferenceError: a is not defined
```

**undefined与null值**
> 目前，null和undefined基本是同义的，只有一些细微的差别。
1. null表示"没有对象"，即该处不应该有值。(值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。)[参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)
 (1) null可以被转换成数字0而undefined不可以（null会执行类型转换undefined不会）
 ```js
typeof null        // "object" (因为一些以前的原因而不是'null')
typeof undefined   // "undefined"
null === undefined // false
null  == undefined // true
null === null // true
null == null // true
!null //true
isNaN(1 + null) // false
isNaN(1 + undefined) // true
 ```
2. undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
 ```js
 'use strict'
 var a = {}
 console.log(a.title) // undefined

 function testFunc(a){
     console.log(a)
 }
 testFunc() // undefined

 console.log(testFunc()) // undefined
 ```
 
## 作用域
作用域是根据名称查找变量的一套规则;当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止

1. 简单例子
```javascript
function foo(a) {     
    console.log( a + b ); 
} 
 
var b = 2; 
 
foo(2); // 4

```
> 上面代码，在foo()中是无法找到b的声明的，这时候就会查询上一级作用域（在这个例子中就是全局作用域）发现了b

2. 图片参考
![作用域图片](/images/scope.png)

这个建筑代表程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是执行代码所处的位置。建筑的顶层代表全局作用域。
LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼， 如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你 所需的变量，也可能没找到，但无论如何查找过程都将停止。

>RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。
你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的 值”。

## 总结
**作用域**是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。
赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作。
JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声 明会被分解成两个独立的步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 
2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。
LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。


    
